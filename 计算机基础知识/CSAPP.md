# CSAPP

## 第一章:计算机系统漫游

计算机系统是由硬件和软件组成。所有计算机系统都有相似的硬件和软件组件， 它们又执行着相似的功能。

```c
#include<stdio.h>

int main()
{
	printf("hello,world\n");
	return 0;
}
```

跟踪hello程序的生命周期来开始对系统的学习

### 1.1信息就是位+上下文

源程序实际上就是一个由值0和1组成的位（又称为比特）序列， 8 个位被组织成一组， 称为字节。

大部分的现代计算机系统都使用ASCII标准来表示文本字符， 这种方式实际上就是用一个唯一的单字节大小的整数值气 来表示每个字符。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20210325-1720315140712.png)

像 hello.c这样只由 ASCII字符构成的文件称为文本文件， 所有其他文件都称为二进制文件。

hello.c的表示方法说明了一个基本思想：系统中所有的信息包括磁盘文件、 内存中的程序、 内存中存放的用户数据以及网络上传送的数据， 都是由一串比特表示的。 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。 比如， 在不同的上下文中，一个同样的字节序列可能表示一个整数、 浮点数、 字符串或者机器指令。

### 1.2程序被其他程序翻译成不同的格式

在Unix系统上， 从源文件到目标文件的转化是由编译器驱动程序完成的：linux> gee  -o hello hello.e 

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20210454-1720315155760.png)

- 处理阶段。预处理器(cpp)根据以字符＃开头的命令， 修改原始的C程序。 比如hello.c中第1行的五nclude <stdio. h> 命令告诉预处理器读取系统头文件stdio.h的内容， 并把它直接插入程序文本中。 结果就得到了另一个C程序， 通常是以．l作为文件扩展名。

- 编译阶段。 编译器(eel)将文本文件hello.i翻译成文本文件hello.s, 它包含一个汇编语言程序。 该程序包含函数main的定义， 如下所示：

  ```c
  main: 
    subq $8,  %rsp 
    movl $.LCO,  %edi 
    call puts 
    movl $0,  %eax 
    addq $8,  %rsp 
    ret
  ```

  定义中2~7行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的， 因为它为不同高级语言的不同编译器提供了通用的输出语言。 例如， C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。

- 汇编阶段。 接下来， 汇编器(as)将hello.s翻译成机器语言指令， 把这些指令打包成一种叫做可重定位目标程序(relocatable object program)的格式， 并将结果保存在目标文件hello.o中。 hello.o文件是一个**二进制文件**， 它包含的17个字节是函数main的指令编码。 如果我们在文本编辑器中打开 he llo.o文件， 将看到一堆乱码。

- 链接阶段。请注意， he荨o程序调用了 printf 函数， 它是每个C 编译器都提供的标准C库中的一个函数。printf 函数存在于一个名为 printf.o的单独的预编译好了的目标文件中， 而这个文件必须以某种方式合并到我们的 he荨o.o程序中。 链接器(Id)就负责处理这种合并。 结果就得到hello文件， 它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中， 由系统执行。

### 1.3了解编译系统如何工作的益处

#### 1.3.1优化程序性能

 为了在 C程序中做出好的编码选择， 我们确实需要了解一些机器代码以及编译器将不同的C语旬转化为机器代码的方式。 

#### 1.3.2理解链接时出现的错误

根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。

#### 1.3.3避免安全漏洞

多年来， 缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。

### 1.4处理器读并解释储存在内存中的指令

```shell
linux> ./hello 
hello,world 
linux> 
```

shell是一个命令行解释器， 它输出一个提示符，等待输入一个命令行， 然后执行这个命令。 如果该命令行的第一个单词不是一个内置的shell命令， 那么shell就会假设这是一个可执行文件的名字， 它将加载并运行这个文件。 所以在此例中， shell将加载并运行hello程序， 然后等待程序终止。hello程序在屏幕上输出它的消息，然后终止。shell随后输出一个提示符， 等待下一个输入的命令行。

#### 1.4.1系统硬件的组成

为了理解运行hello程序时发生了什么，我们需要了解一个典型系统的硬件组织

##### 1.总线

贯穿整个系统的是一组电子管道， 称作总线， 它携带信息字节并负责在各个部件间传递。 **通常总线被设计成传送定长的字节块，也就是字(word)。字中的字节数（即字长）是一个基本的系统参数， 各个系统中都不尽相同。 现在的大多数机器字长要么是4个字节(32位）， 要么是8个字节(64位）。** 本书中， 我们不对字长做任何固定的假设。 相反， 我们将在需要明确定义的上下文中具体说明一个”字”是多大。

##### 2.I/O设备

I/0（输入／输出）设备是系统与外部世界的联系通道。 我们的示例系统包括四个I/0设备： **作为用户输入的键盘和鼠标， 作为用户输出的显示器， 以及用千长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。**最开始， 可执行程序hello就存放在磁盘上。

每个I/0设备都通过一个控制器或适配器与I/0总线相连。 控制器和适配器之间的区别主要在千它们的封装方式。 控制器是 I/0设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。 而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在1/0总线和1/0设备之间传递信息。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20210531-1720315175512.png)

##### 3.主存

主存是一个临时存储设备， 在处理器执行程序时，S用来存放程序和程序处理的数据。 **从物理上来说， 主存是由一组动态随机存取存储器(DRAM)芯片组成的。 从逻辑上来说， 存储器是一个线性的字节数组， 每个字节都有其唯一的地址（数组索引）， 这些地址是从零开始的。** 一般来说， 组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。 比如， 在运行Linux的 x86-64机器上， short类型的数据需要2 个字节，int和 float类型需要4个字节， 而long和double类型需要8个字节。

##### 4.处理器

中央处理单元(CPU)，简称处理器， 是解释（或执行）**存储在主存中指令的引擎。 处理器的核心是一个大小为一个字的存储设备（或寄存器）， 称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。**

从系统通电开始， 直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。 处理器看上去是按照一个非常简单的指令执行模型来操作的， 这个模型是由指令集架构决定的。 在这个模型中， 指令按照严格的顺序执行， 而执行一条指令包含执行一系列的步骤。**处理器从程序计数器指向的内存处读取指令， 解释指令中的位， 执行该指令指示的简单操作， 然后更新 PC, 使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。**

这样的简单操作并不多，它们围绕着主存、寄存器文件(registerfile)和算术／逻辑单元(ALU)进行。 寄存器文件是一个小的存储设备， 由一些单个字长的寄存器组成， 每个寄存器都有唯一的名字。ALU计算新的数据和地址值。 下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作。

- 加载：从主存复制一个字节或者一个字到寄存器， 以覆盖寄存器原来的内容。
- 存储： 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
- 操作： 把两个寄存器的内容复制到ALU, ALU对这两个字做算术运算， 并将结果存放到一个寄存器中， 以覆盖该寄存器中原来的内容。
- 跳转:从指令本身中抽取一个字，将这些字复制到程序计数器(PC)中， 以覆盖PC 中原来的值。

 指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。

#### 1.4.2运行hello程序

初始时，shell程序执行它的指令， 等待我们输入一个命令。 当我们在键盘上输入字符串"./hello" 后， shell程序将字符逐一读入寄存器， 再把它存放到内存中， 如图1-5 所示。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20092028-1720315284179.png)

当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。 然后shell执行一系列指令来加载可执行的 hello文件， 这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。 数据包括最终会被输出的字符串“hello, world\n”。

利用直接存储器存取CDMA, 将在第 6 章中讨论）技术， 数据可以不通过处理器而直接从磁盘到达主存。 这个步骤如图1-6 所示。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20092253.png)

一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行 hello程序的main程序中的机器语言指令。 这些指令将“hello, world\n"字符串中的字节从主存复制到寄存器文件， 再从寄存器文件中复制到显示设备， 最终显示在屏幕上。 这个步骤如图1-7所示。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20092336.png)

### 1.5高速缓存至关重要

系统花费了大量的时间把信息从一个地方挪到另一个地方。

hello程序的机器指令最初是存放在磁盘上， 当程序加载时，它们被复制到主存； 当处理器运行程序时， 指令又从主存复制到处理器。 相似地，数据串“hel ­lo, world/n"开始时在磁盘上， 然后被复制到主存， 最后从主存上复制到显示设备。

较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。 

针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储(cachememory,简称为cache或高速缓存）， 作为暂时的集结区域， 存放处理器近期可能会需要的信息。

 图1-8展示了一个典型系统中的高速缓存存储器。 

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20095643.png)

位千处理器芯片上的Ll 高速缓存的容量可以达到数万字节， 访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的L2 高速缓存通过一条特殊的总线连接到处理器。 进程访问L2 高速缓存的时间要比访问Ll 高速缓存的时间长5倍， 但是这仍然比访问主存的时间快5~10倍。 Ll 和L2高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。 比较新的、 处理能力更强大的系统甚至有三级高速缓存：Ll、 L2和L3。系统可以获得一个很大的存储器， 同时访问速度也很快， 原因是利用了高速缓存的局部性原理， 即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据， 大部分的内存操作都能在快速的高速缓存中完成。

### 1.6存储设备形成层次结构

每个计算机系统中的存储设备都被组织成了一个存储器层次结构，如图 1-9 所示。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20095943.png)

 在这个层次结构中， 从上至下， 设备的访问速度越来越慢、 容最越来越大， 并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部， 也就是第0级或记为L0。 这里我们展示的是三层高速缓存Ll 到L3,占据存储器层次结构的第1层到第3层。 主存在第4层， 以此类推。

**存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。**在某些具有分布式文件系统的网络系统中， 本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。

### 1.7操作系统管理硬件

回到hello程序的例子。 当shell加载和运行hello程序时，以及hello程序输出自己的消息时，shell 和 hello程序都没有直接访问键盘、 显示器、 磁盘或者主存。 取而代之的是， 它们依靠操作系统提供的服务。 **我们可以把操作系统看成是应用程序和硬件之间插入的一层软件**，  如图1-10所示。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20100852.png)

操作系统有两个基本功能：

(1)防止硬件被失控的应用程序滥用 。

(2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。 如图1-11所示

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20101149.png)

文件是对I/0设备的抽象表示， 虚拟内存是对主存和磁盘I/0设备的抽象表示， 进程则是对处理器、 主存和I/0设备的抽象表示。 我们将依次讨论每种抽象表示。

#### 1.7.1进程

**进程是操作系统对一个正在运行的程序的一种抽象。**在一个系统上可以同时运行多个进程， 而每个进程都好像在独占地使用硬件。 **而并发运行， 则是说一个进程的指令和另一个进程的指令是交错执行的。** 在大多数系统中， 需要运行的进程数是多千可以运行它们的CPU个数的。 **传统系统在一个时刻只能执行一个程序， 而先进的多核处理器同时能够执行多个程序。** 无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程， 这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。

**操作系统保持跟踪进程运行所需的所有状态信息。** 这种状态， 也就是上下文， 包括许多信息， 比如PC和寄存器文件的当前值， 以及主存的内容。**在任何一个时刻， 单处理器系统都只能执行一个进程的代码。 当操作系统决定要把控制权从当前进程转移到某个新进程时， 就会进行上下文切换， 即保存当前进程的上下文、 恢复新进程的上下文，然后将控制权传递到新进程。 新进程就会从它上次停止的地方开始。**图1-12展示了示例hello程序运行场景的基本理念。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20102318.png)

从一个进程到另一个进程的转换是由操作系统内核(kerne l)管理的。内核是操作系统代码常驻主存的部分。 当应用程序需要操作系统的某些操作时， 比如读写文件， 它就执行一条特殊的系统调用(systemcall)指令， 将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。**注意，内核不是一个独立的进程。 相反， 它是系统管理全部进程所用代码和数据结构的集合。**

#### 1.7.2线程

尽管通常我们认为一个进程只有单一的控制流， 但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成， 每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。 由于网络服务器中对并行处理的需求， 线程成为越来越重要的编程模型， 因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。 当有多处理器可用的时候， 多线程也是一种使得程序可以运行得更快的方法。

#### 1.7.3虚拟内存

虚拟内存是一个抽象概念， 它为每个进程提供了一个假象， 即每个进程都在独占地使用主存。 每个进程看到的内存都是一致的， 称为虚拟地址空间。图1-13所示的是 Linux进程的虚拟地址空间（其他Unix系统的设计也与此类似）。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20105151.png)

在Linux中， 地址空间最上面的区域是保留给操作系统中的代码和数据的， 这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。 请注意， 图 中的地址是从下往上增大的。

每个进程看到的虚拟地址空间由大量准确定义的区构成， 每个区都有专门的功能。 

- 序代码和数据：对所有的进程来说， 代码是从同一固定地址开始， 紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行 目标文件的内容初始化的， 在示例中就是可执行文件hello。 
- 堆：代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小， 与此不同， 当调用像malloc和 free这样的C 标准库函数时，堆可以在运行时动态地扩展和收缩。 
- 共享库：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。
- 栈：位千用户虚拟地址空间顶部的是用户栈， 编译器用它来实现函数调用。和堆一样， 用户栈在程序执行期间可以动态地扩展和收缩。 特别地， 每次我们调用一个函数时， 栈就会增长； 从一个函数返回时，栈就会收缩。
- 内核虚拟内存：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反， 它们必须调用内核来执行这些操作。

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互， 包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。 

#### 1.7.4文件

文件就是字节序列， 仅此而已。 每个 I/0 设备， 包括磁盘、键盘、 显示器， 甚至网络， 都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为UnixI/0 的系统函数调用读写文件来实现的。

文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图， 来看待系统中可能含有的所有各式各样的I/0设备。 例如， 处理磁盘文件内容的应用程序员可以非常幸福， 因为他们无须了解具体的磁盘技术。 进一步说， 同一个程序可以在使用不同磁盘技术的不同系统上运行。

### 1.8系统之间利用网络通信

现代系统经常通过网络和其他系统连接到一起。 从一个单独的系统来看， 网络可视为一个I/0设备， 如图1-14所示 。 当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20112041.png)

回到hello示例， 我们可以使用熟悉的telnet 应用在一个远程主机上运行hello 程序。．假设用本地主机上的telnet客户端连接远程主机上的telnet服务器。 在我们登录到远程主机并运行shell 后， 远端的shell 就在等待接收输入命令。此后在远端运行hello 程序包括如图1-15所示的五个基本步骤。

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-07%20112302.png)

### 1.9重要主题

系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。 

#### 1.9.1Amdahl定律

![](CSAPP.assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-08%20095847.png)

